// PDA Tutorial Content - Rigorous Treatment

export const pdaTutorial = {
    description: "Master Pushdown Automata and context-free languages through formal definitions, stack operations, and equivalence with context-free grammars.",
    lessons: [
        {
            id: 'pda-0',
            title: 'Introduction: Beyond Finite Memory',
            description: 'An intuitive introduction to Pushdown Automata and why we need stacks',
            steps: [
                {
                    title: 'The Machine for CFGs',
                    content: `We've seen that:

• Regular Languages are recognized by Finite Automata (DFAs/NFAs).
• Context-Free Languages are generated by Context-Free Grammars (CFGs).

What is the automaton (recognizer) for a Context-Free Language?

The answer is the Pushdown Automaton (PDA).`,
                    keyPoints: [
                        'CFGs generate languages',
                        'PDAs recognize languages',
                        'PDAs are the automaton equivalent of CFGs',
                        'This completes the picture: generators ↔ recognizers'
                    ]
                },
                {
                    title: 'Why Finite Automata Fail',
                    content: `Why can't a DFA recognize L = {0ⁿ1ⁿ | n ≥ 0}?

A DFA has only a finite number of states. It has no "memory" to count how many 0s it has seen, in order to check if it matches the number of 1s.

Example:
• "0011" needs to remember: "I saw 2 zeros"
• "000111" needs to remember: "I saw 3 zeros"
• "00001111" needs to remember: "I saw 4 zeros"

Since n can be arbitrarily large, a finite automaton cannot store this count.`,
                    keyPoints: [
                        'DFAs have finite memory (states only)',
                        'Cannot count unboundedly',
                        'Need a way to store arbitrary amounts of information',
                        'This is where stacks come in!'
                    ],
                    tips: [
                        'Think: "How many states would I need?"',
                        'For 0ⁿ1ⁿ, you\'d need infinitely many states',
                        'Finite automata are fundamentally limited',
                        'We need a new model of computation'
                    ]
                },
                {
                    title: 'The Power of a Stack',
                    content: `A Pushdown Automaton is essentially a Nondeterministic Finite Automaton (NFA) with one extra component: a stack.

A stack is a "Last-In, First-Out" (LIFO) data structure.

Operations:
• PUSH: Add an item to the top of the stack.
• POP: Remove the top item from the stack.

This stack gives the automaton a simple, but infinite, memory. It can use the stack to "count."

How a PDA recognizes L = {0ⁿ1ⁿ}:

1. While reading '0's, PUSH a '0' (or some marker, say '$') onto the stack for each '0' read.
2. When you start reading '1's, POP one '0' from the stack for each '1' read.
3. If the stack becomes empty at the exact same time you finish reading the string, you have a match. Accept the string.

Rejection cases:
• If you run out of input '1's but the stack still has '0's (e.g., "00011") → Reject
• If you still have '1's to read but the stack is empty (e.g., "00111") → Reject
• If you see a '0' after a '1' (e.g., "0101") → Reject (handled by state logic)`,
                    keyPoints: [
                        'Stack provides unlimited memory (but LIFO access)',
                        'Can count by pushing/popping',
                        'Perfect for matching pairs',
                        'More powerful than finite automata'
                    ],
                    example: {
                        description: 'Tracing "0011" on a PDA',
                        code: `Input: "0011"
Stack: [$]  (bottom marker)

Read '0': Push '0' → Stack: [0, $]
Read '0': Push '0' → Stack: [0, 0, $]
Read '1': Pop '0'  → Stack: [0, $]
Read '1': Pop '0'  → Stack: [$]

Input finished, stack has only $ → ACCEPT! ✓

Input: "00011"
Read '0': Push → [0, $]
Read '0': Push → [0, 0, $]
Read '0': Push → [0, 0, 0, $]
Read '1': Pop  → [0, 0, $]
Read '1': Pop  → [0, $]

Input finished, but stack still has '0' → REJECT! ✗`
                    }
                },
                {
                    title: 'How a PDA Works',
                    content: `A PDA's transition depends on three things:

1. The current state.
2. The current input symbol (or ε).
3. The symbol at the top of the stack.

Based on these three things, the PDA does two things:

1. Transitions to a new state.
2. Modifies the stack (it can PUSH, POP, or do nothing).

Note: PDAs are almost always nondeterministic. A 'Deterministic PDA' (DPDA) is a much weaker model and cannot recognize all CFLs. The nondeterminism is crucial for "guessing" (e.g., "is this the middle of the string?").`,
                    keyPoints: [
                        'PDAs read: state + input + stack top',
                        'PDAs write: new state + stack modification',
                        'Nondeterminism is essential',
                        'More powerful than deterministic PDAs'
                    ],
                    tips: [
                        'Think of the stack as "memory"',
                        'Only the top is accessible',
                        'LIFO structure is perfect for nested structures',
                        'Nondeterminism helps with "guessing" structure'
                    ]
                },
                {
                    title: 'Two Types of Acceptance',
                    content: `A PDA can accept a string in two different (but equivalent) ways:

1. Acceptance by Final State: The machine finishes reading the input and is in an accept state (just like an NFA).

2. Acceptance by Empty Stack: The machine finishes reading the input, and the stack is empty (regardless of what state it's in).

These two models of acceptance are equivalent in power (you can convert one to the other).

Example (Empty Stack):
For L = {0ⁿ1ⁿ}, we:
• Push on 0s
• Pop on 1s
• Accept when stack is empty

This is often more intuitive for matching problems.`,
                    keyPoints: [
                        'Two equivalent acceptance modes',
                        'Final state: like NFAs',
                        'Empty stack: unique to PDAs',
                        'Choose whichever is more convenient'
                    ]
                },
                {
                    title: 'The Stack and Context',
                    content: `Adding a stack changes computation fundamentally by providing a form of memory that is not limited by the fixed number of states.

While a finite automaton (DFA/NFA) can only make decisions based on the current input symbol and state, a PDA can use the stack to store **context**. 

Key points about the PDA stack:
• **Non-local decisions**: The stack allows the machine to remember something from the beginning of the string and use it at the very end. This is essential for matching structures like $0^n1^n$ or balanced parentheses.
• **LIFO structure**: Last-In, First-Out. You can only "see" and interact with the most recent item added to the top of the stack.
• **Infinite memory**: Unlike the finite set of states ($Q$), which is fixed in number, the stack can grow to any depth needed during computation.

**The "$" Symbol**:
A common convention in PDA design is to push a special symbol (often "$" or $Z_0$) onto the stack at the very beginning. This acts as a **bottom marker**, allowing the machine to detect when the stack has been emptied and it has returned to its initial context.`,
                    keyPoints: [
                        'The stack provides a limited but infinite source of memory',
                        'It allows the automaton to track recursive and nested structures',
                        'LIFO access ensures that context is processed in reverse-order of entry',
                        'The bottom marker is crucial for distinguishing an empty stack from an uninitialized one'
                    ],
                    tips: [
                        'Think of the stack as a "to-do list" where you only do the top item',
                        'If you need to match two parts of a string, push the first part and pop for the second',
                        'Always start your PDA logic by pushing a bottom marker'
                    ]
                }
            ]
        },
        {
            id: 'pda-1',
            title: 'Formal Definition and Stack Operations',
            description: 'Rigorous treatment of PDAs including formal definitions and stack semantics',
            steps: [
                {
                    title: 'Formal Definition of a PDA',
                    content: `A Pushdown Automaton is a 7-tuple P = (Q, Σ, Γ, δ, q₀, Z₀, F) where:

• Q is finite set of states
• Σ is input alphabet
• Γ is stack alphabet
• δ: Q × Σ_ε × Γ_ε → P(Q × Γ*) is transition function
• q₀ ∈ Q is start state
• Z₀ ∈ Γ is initial stack symbol
• F ⊆ Q is set of accept states

Key: δ(q, a, X) returns set of pairs (p, γ) where p is next state and γ is string to push onto stack (top symbol X is replaced by γ).

Acceptance modes:
1. Accept by final state: δ*(q₀, w, Z₀) ⊢* (f, ε, α) for some f ∈ F, α ∈ Γ*
2. Accept by empty stack: δ*(q₀, w, Z₀) ⊢* (q, ε, ε) for any q ∈ Q`,
                    example: {
                        description: 'PDA accepting {0ⁿ1ⁿ | n ≥ 0}',
                        code: `P = (Q, Σ, Γ, δ, q₀, Z₀, F):

Q = {q₀, q₁, q₂}
Σ = {0, 1}
Γ = {Z₀, X}
F = {q₂}

δ(q₀, 0, Z₀) = {(q₀, XZ₀)}  // Push X
δ(q₀, 0, X) = {(q₀, XX)}    // Push X
δ(q₀, ε, Z₀) = {(q₁, Z₀)}  // Switch to popping
δ(q₀, ε, X) = {(q₁, X)}    
δ(q₁, 1, X) = {(q₁, ε)}    // Pop X
δ(q₁, ε, Z₀) = {(q₂, Z₀)}  // Accept`
                    },
                    keyPoints: [
                        'Stack provides unlimited memory (but only top accessible)',
                        'δ can push/pop/replace multiple symbols atomically',
                        'ε-transitions allow state changes without reading input',
                        'Two acceptance modes are equivalent in power'
                    ]
                },
                {
                    title: 'Instantaneous Descriptions and Computations',
                    content: `An Instantaneous Description (ID) is a triple (q, w, γ) where:
• q ∈ Q is current state
• w ∈ Σ* is remaining input
• γ ∈ Γ* is stack contents (top at left)

Transition relation ⊢:
(q, aw, Xβ) ⊢ (p, w, αβ) if (p, α) ∈ δ(q, a, X)

Reflexive transitive closure ⊢* represents computation.

Acceptance (final state):
w ∈ L(P) ⟺ ∃f ∈ F, γ ∈ Γ*: (q₀, w, Z₀) ⊢* (f, ε, γ)

Acceptance (empty stack):
w ∈ N(P) ⟺ ∃q ∈ Q: (q₀, w, Z₀) ⊢* (q, ε, ε)`,
                    keyPoints: [
                        'IDs formalize PDA configurations',
                        '⊢ is single-step transition relation',
                        '⊢* is multi-step computation',
                        'This notation is standard in formal language theory'
                    ]
                },
                {
                    title: 'Equivalence of Acceptance Modes',
                    content: `Theorem: For any PDA P accepting by final state, there exists PDA P' accepting by empty stack with L(P) = N(P'), and vice versa.

Proof sketch (final → empty):
1. Add new start state q₀' with ε-transition pushing special bottom marker
2. From any final state, add ε-transitions to new state that pops everything

Proof sketch (empty → final):
1. Add new bottom marker X₀
2. Add new final state qf
3. When X₀ is exposed (stack would be empty), go to qf

Conclusion: Both models are equivalent, so we can use whichever is more convenient.`,
                    keyPoints: [
                        'Acceptance modes are equivalent in computational power',
                        'Conversion is constructive (algorithmic)',
                        'Choice of mode is matter of convenience',
                        'Most theory uses final state acceptance'
                    ]
                }
            ]
        },
        {
            id: 'pda-2',
            title: 'Context-Free Languages and PDAs',
            description: 'The fundamental connection between PDAs and context-free grammars',
            steps: [
                {
                    title: 'PDA ↔ CFG Equivalence Theorem',
                    content: `Fundamental Theorem: A language L is accepted by some PDA if and only if L is generated by some context-free grammar.

Formally: L is context-free ⟺ ∃ PDA P with L = L(P)

This establishes PDAs as recognizers for exactly the context-free languages!

Proof has two parts:
1. CFG → PDA: Construct PDA that simulates leftmost derivations
2. PDA → CFG: Construct CFG that generates accepting computations

Both constructions are algorithmic and effective.`,
                    keyPoints: [
                        'PDAs and CFGs characterize the same class of languages',
                        'PDAs are recognizers (bottom-up)',
                        'CFGs are generators (top-down)',
                        'This is analogous to DFA ↔ Regular Expression'
                    ]
                },
                {
                    title: 'CFG to PDA Construction',
                    content: `Given CFG G = (V, T, P, S), construct PDA P:

Idea: Simulate leftmost derivations on the stack.

Construction:
• Single state q
• Stack alphabet Γ = V ∪ T
• For each production A → α: δ(q, ε, A) contains (q, α)
• For each terminal a: δ(q, a, a) = {(q, ε)}
• Start with S on stack

Operation:
1. Nondeterministically apply productions (expand variables)
2. Match terminals with input
3. Accept by empty stack

Correctness: S ⇒* w in G ⟺ (q, w, S) ⊢* (q, ε, ε) in P`,
                    example: {
                        description: 'CFG to PDA for balanced parentheses',
                        code: `Grammar:
S → (S) | SS | ε

PDA transitions:
δ(q, ε, S) = {(q, (S)), (q, SS), (q, ε)}
δ(q, (, () = {(q, ε)}  // Match (
δ(q, ), )) = {(q, ε)}  // Match )

Accepts: (), (()), (())(), etc.`
                    },
                    keyPoints: [
                        'Construction is simple and direct',
                        'Single state suffices',
                        'Nondeterminism chooses which production to apply',
                        'Stack holds sentential form of derivation'
                    ]
                }
            ]
        }
    ],
    exercises: [
        {
            id: 'pda-ex-basics',
            title: 'Basics: Stack Behavior',
            description: 'Test your understanding of how stacks change computation',
            questions: [
                {
                    type: 'multiple-choice',
                    question: 'What does it mean for a PDA to make "non-local" decisions?',
                    options: [
                        'It can jump to any state at any time',
                        'It can move its head to any position on the input',
                        'It can use the stack to use information from earlier in the string to decide current transitions',
                        'It can communicate with other automata'
                    ],
                    correctAnswer: 'It can use the stack to use information from earlier in the string to decide current transitions',
                    explanation: 'The instructor guide explains that the stack allows the PDA to store context, meaning it can make decisions based on contents that were pushed much earlier in the computation.',
                    hint: 'Think about how a matching parenthesis knows it has a pair.'
                },
                {
                    type: 'multiple-choice',
                    question: 'What is the primary purpose of pushing a special symbol like "$" onto the stack first?',
                    options: [
                        'To make the stack look more complex',
                        'To allow the machine to detect when the stack is back to its "empty" state',
                        'To satisfy the formal definition requirements',
                        'To represent the start state'
                    ],
                    correctAnswer: 'To allow the machine to detect when the stack is back to its "empty" state',
                    explanation: 'The "$" marker serves as a bottom-of-stack indicator. When the machine pops and sees "$", it knows it has matched all the symbols it previously pushed.',
                    hint: 'How do you know when you\'ve finished matching all your pairs?'
                },
                {
                    type: 'true-false',
                    question: 'In a LIFO structure, you can access any item in the stack as long as you know its position.',
                    options: ['True', 'False'],
                    correctAnswer: 'False',
                    explanation: 'False. In a LIFO (Last-In, First-Out) structure, only the top element is accessible. You must pop all elements above an item to reach it.',
                    hint: 'Think about a stack of plates.'
                }
            ]
        },
        {
            id: 'pda-ex-1',
            title: 'PDA Formal Definitions',
            description: 'Test understanding of PDA formalism',
            questions: [
                {
                    type: 'multiple-choice',
                    question: 'What is the type signature of the PDA transition function δ?',
                    options: [
                        'δ: Q × Σ × Γ → Q × Γ*',
                        'δ: Q × Σ_ε × Γ_ε → P(Q × Γ*)',
                        'δ: Q × Σ* × Γ* → Q',
                        'δ: Q × Γ → Q × Σ'
                    ],
                    correctAnswer: 'δ: Q × Σ_ε × Γ_ε → P(Q × Γ*)',
                    explanation: 'The PDA transition function takes (state, input symbol or ε, stack top or ε) and returns a set of (new state, string to push) pairs.',
                    hint: 'Remember PDAs are nondeterministic and can have ε-transitions.'
                },
                {
                    type: 'true-false',
                    question: 'Acceptance by final state and acceptance by empty stack are equivalent in power.',
                    options: ['True', 'False'],
                    correctAnswer: 'True',
                    explanation: 'True! Any PDA accepting by one mode can be converted to accept by the other mode while recognizing the same language.',
                    hint: 'Think about the conversion constructions.'
                },
                {
                    type: 'multiple-choice',
                    question: 'Which language CANNOT be recognized by any PDA?',
                    options: [
                        '{0ⁿ1ⁿ | n ≥ 0}',
                        '{0ⁿ1ⁿ2ⁿ | n ≥ 0}',
                        '{wwᴿ | w ∈ {0,1}*}',
                        'Balanced parentheses'
                    ],
                    correctAnswer: '{0ⁿ1ⁿ2ⁿ | n ≥ 0}',
                    explanation: 'This language requires counting three separate groups, which needs two counters. A PDA has only one stack (one counter).',
                    hint: 'How many independent counts does each language require?'
                },
                {
                    type: 'multiple-choice',
                    question: 'In an instantaneous description (q, w, γ), what does γ represent?',
                    options: [
                        'The input string',
                        'The set of final states',
                        'The stack contents with top at left',
                        'The transition function'
                    ],
                    correctAnswer: 'The stack contents with top at left',
                    explanation: 'In ID notation (q, w, γ), γ ∈ Γ* represents the stack contents with the leftmost symbol being the top.',
                    hint: 'An ID captures the complete configuration of the PDA.'
                }
            ]
        },
        {
            id: 'pda-ex-2',
            title: 'Hands-On: Build Your Own PDAs',
            description: 'Practice building Pushdown Automata in the simulator with guided challenges',
            questions: [
                {
                    type: 'hands-on',
                    question: 'Build a PDA that accepts the language {0ⁿ1ⁿ | n ≥ 0}',
                    simulatorType: 'PDA',
                    challenge: {
                        alphabet: ['0', '1'],
                        stackAlphabet: ['Z', 'X'],
                        description: 'Create a Pushdown Automaton that accepts equal numbers of 0s followed by 1s (including the empty string). Your PDA should accept "", "01", "0011", "000111", but reject "0", "1", "001", "0110".',
                        testCases: [
                            { input: '', expected: true, description: 'Empty string (n=0)' },
                            { input: '01', expected: true, description: 'n=1' },
                            { input: '0011', expected: true, description: 'n=2' },
                            { input: '000111', expected: true, description: 'n=3' },
                            { input: '0', expected: false, description: 'More 0s than 1s' },
                            { input: '1', expected: false, description: 'More 1s than 0s' },
                            { input: '001', expected: false, description: 'Unequal counts' },
                            { input: '0110', expected: false, description: 'Wrong order' }
                        ],
                        hints: [
                            'Use the stack to count 0s: push a symbol (like X) for each 0.',
                            'When you see a 1, start popping the symbols from the stack.',
                            'Accept only if you finish reading the input and the stack is back to its start symbol.',
                            'You need at least three states: q0 (start), q1 (counting/popping), and q2 (final/accept).'
                        ]
                    },
                    explanation: 'This PDA uses its stack as a counter. Each 0 adds to the stack, and each 1 removes from it, ensuring they match exactly.'
                },
                {
                    type: 'hands-on',
                    question: 'Build a PDA for Balanced Parentheses over {(, )}',
                    simulatorType: 'PDA',
                    challenge: {
                        alphabet: ['(', ')'],
                        stackAlphabet: ['Z', '('],
                        description: 'Design a PDA that accepts strings of balanced parentheses. It should accept "", "()", "(())", "()()", "(()())", but reject "(", ")", "()(", "())".',
                        testCases: [
                            { input: '', expected: true, description: 'Empty string' },
                            { input: '()', expected: true, description: 'Simple pair' },
                            { input: '(())', expected: true, description: 'Nested' },
                            { input: '()()', expected: true, description: 'Sequence' },
                            { input: '(()())', expected: true, description: 'Complex' },
                            { input: '(', expected: false, description: 'Unclosed' },
                            { input: ')', expected: false, description: 'Unopened' },
                            { input: '())', expected: false, description: 'Extra closing' },
                            { input: '(()', expected: false, description: 'Extra opening' }
                        ],
                        hints: [
                            'Push an opening parenthesis onto the stack whenever you see one.',
                            'Pop from the stack whenever you see a closing parenthesis.',
                            'If you see a closing parenthesis and the stack is empty (or has only the bottom marker), that\'s a rejection.',
                            'Accept if the stack is empty at the end of the input.'
                        ]
                    },
                    explanation: 'A PDA is the perfect machine for balanced parentheses because its stack naturally mirrors the nesting structure of the language.'
                },
                {
                    type: 'hands-on',
                    question: 'Build a PDA for the Palindrome Language {w c wᴿ | w ∈ {0,1}*}',
                    simulatorType: 'PDA',
                    challenge: {
                        alphabet: ['0', '1', 'c'],
                        stackAlphabet: ['Z', '0', '1'],
                        description: 'Build a PDA that accepts strings with a "c" in the middle, where the second half is the reverse of the first half. Examples: "c", "0c0", "1c1", "01c10", "110c011". Reject: "0c1", "01c01", "01".',
                        testCases: [
                            { input: 'c', expected: true, description: 'Empty w' },
                            { input: '0c0', expected: true, description: 'Single 0' },
                            { input: '1c1', expected: true, description: 'Single 1' },
                            { input: '01c10', expected: true, description: 'Binary string' },
                            { input: '110c011', expected: true, description: 'Binary string' },
                            { input: '0c1', expected: false, description: 'Mismatch' },
                            { input: '01c01', expected: false, description: 'Not reversed' },
                            { input: '01', expected: false, description: 'Missing center' }
                        ],
                        hints: [
                            'Push all symbols (0s and 1s) onto the stack until you reach the center character "c".',
                            'Ignore the "c" and switch to a new state for the second half of the string.',
                            'In the second half, pop from the stack and ensure it matches the current input symbol.',
                            'If at any point the stack top doesn\'t match the input, the string is not a palindrome.'
                        ]
                    },
                    explanation: 'The "c" acts as a marker telling the PDA exactly when to stop pushing and start popping to verify the reverse string.'
                }
            ]
        }
    ]
};


