// PDA Tutorial Content - Rigorous Treatment

export const pdaTutorial = {
    description: "Master Pushdown Automata and context-free languages through formal definitions, stack operations, and equivalence with context-free grammars.",
    lessons: [
        {
            id: 'pda-0',
            title: 'Introduction: Beyond Finite Memory',
            description: 'An intuitive introduction to Pushdown Automata and why we need stacks',
            steps: [
                {
                    title: 'The Machine for CFGs',
                    content: `We've seen that:

• Regular Languages are recognized by Finite Automata (DFAs/NFAs).
• Context-Free Languages are generated by Context-Free Grammars (CFGs).

What is the automaton (recognizer) for a Context-Free Language?

The answer is the Pushdown Automaton (PDA).`,
                    keyPoints: [
                        'CFGs generate languages',
                        'PDAs recognize languages',
                        'PDAs are the automaton equivalent of CFGs',
                        'This completes the picture: generators ↔ recognizers'
                    ]
                },
                {
                    title: 'Why Finite Automata Fail',
                    content: `Why can't a DFA recognize L = {0ⁿ1ⁿ | n ≥ 0}?

A DFA has only a finite number of states. It has no "memory" to count how many 0s it has seen, in order to check if it matches the number of 1s.

Example:
• "0011" needs to remember: "I saw 2 zeros"
• "000111" needs to remember: "I saw 3 zeros"
• "00001111" needs to remember: "I saw 4 zeros"

Since n can be arbitrarily large, a finite automaton cannot store this count.`,
                    keyPoints: [
                        'DFAs have finite memory (states only)',
                        'Cannot count unboundedly',
                        'Need a way to store arbitrary amounts of information',
                        'This is where stacks come in!'
                    ],
                    tips: [
                        'Think: "How many states would I need?"',
                        'For 0ⁿ1ⁿ, you\'d need infinitely many states',
                        'Finite automata are fundamentally limited',
                        'We need a new model of computation'
                    ]
                },
                {
                    title: 'The Power of a Stack',
                    content: `A Pushdown Automaton is essentially a Nondeterministic Finite Automaton (NFA) with one extra component: a stack.

A stack is a "Last-In, First-Out" (LIFO) data structure.

Operations:
• PUSH: Add an item to the top of the stack.
• POP: Remove the top item from the stack.

This stack gives the automaton a simple, but infinite, memory. It can use the stack to "count."

How a PDA recognizes L = {0ⁿ1ⁿ}:

1. While reading '0's, PUSH a '0' (or some marker, say '$') onto the stack for each '0' read.
2. When you start reading '1's, POP one '0' from the stack for each '1' read.
3. If the stack becomes empty at the exact same time you finish reading the string, you have a match. Accept the string.

Rejection cases:
• If you run out of input '1's but the stack still has '0's (e.g., "00011") → Reject
• If you still have '1's to read but the stack is empty (e.g., "00111") → Reject
• If you see a '0' after a '1' (e.g., "0101") → Reject (handled by state logic)`,
                    keyPoints: [
                        'Stack provides unlimited memory (but LIFO access)',
                        'Can count by pushing/popping',
                        'Perfect for matching pairs',
                        'More powerful than finite automata'
                    ],
                    example: {
                        description: 'Tracing "0011" on a PDA',
                        code: `Input: "0011"
Stack: [$]  (bottom marker)

Read '0': Push '0' → Stack: [0, $]
Read '0': Push '0' → Stack: [0, 0, $]
Read '1': Pop '0'  → Stack: [0, $]
Read '1': Pop '0'  → Stack: [$]

Input finished, stack has only $ → ACCEPT! ✓

Input: "00011"
Read '0': Push → [0, $]
Read '0': Push → [0, 0, $]
Read '0': Push → [0, 0, 0, $]
Read '1': Pop  → [0, 0, $]
Read '1': Pop  → [0, $]

Input finished, but stack still has '0' → REJECT! ✗`
                    }
                },
                {
                    title: 'How a PDA Works',
                    content: `A PDA's transition depends on three things:

1. The current state.
2. The current input symbol (or ε).
3. The symbol at the top of the stack.

Based on these three things, the PDA does two things:

1. Transitions to a new state.
2. Modifies the stack (it can PUSH, POP, or do nothing).

Note: PDAs are almost always nondeterministic. A 'Deterministic PDA' (DPDA) is a much weaker model and cannot recognize all CFLs. The nondeterminism is crucial for "guessing" (e.g., "is this the middle of the string?").`,
                    keyPoints: [
                        'PDAs read: state + input + stack top',
                        'PDAs write: new state + stack modification',
                        'Nondeterminism is essential',
                        'More powerful than deterministic PDAs'
                    ],
                    tips: [
                        'Think of the stack as "memory"',
                        'Only the top is accessible',
                        'LIFO structure is perfect for nested structures',
                        'Nondeterminism helps with "guessing" structure'
                    ]
                },
                {
                    title: 'Two Types of Acceptance',
                    content: `A PDA can accept a string in two different (but equivalent) ways:

1. Acceptance by Final State: The machine finishes reading the input and is in an accept state (just like an NFA).

2. Acceptance by Empty Stack: The machine finishes reading the input, and the stack is empty (regardless of what state it's in).

These two models of acceptance are equivalent in power (you can convert one to the other).

Example (Empty Stack):
For L = {0ⁿ1ⁿ}, we:
• Push on 0s
• Pop on 1s
• Accept when stack is empty

This is often more intuitive for matching problems.`,
                    keyPoints: [
                        'Two equivalent acceptance modes',
                        'Final state: like NFAs',
                        'Empty stack: unique to PDAs',
                        'Choose whichever is more convenient'
                    ]
                },
                {
                    title: 'The Big Picture',
                    content: `PDAs are more powerful than NFAs/DFAs, but they are not all-powerful.

For example, a PDA cannot recognize the language L = {aⁿbⁿcⁿ | n ≥ 0}.

Why? It can use its stack to match the a's and b's. But by the time it gets to the c's, the stack is empty, and it has no memory of how many a's and b's it saw. It can't match all three.

The Chomsky Hierarchy (so far):

| Language Class | Generator | Recognizer |
| :--- | :--- | :--- |
| Regular | Regular Grammar | DFA / NFA |
| Context-Free | CFG | PDA |`,
                    keyPoints: [
                        'PDAs recognize context-free languages',
                        'More powerful than finite automata',
                        'But still limited (can\'t do aⁿbⁿcⁿ)',
                        'Part of the Chomsky hierarchy'
                    ],
                    tips: [
                        'One stack = one counter',
                        'aⁿbⁿcⁿ needs two independent counters',
                        'PDAs can\'t do that',
                        'We\'ll need Turing Machines for more power'
                    ]
                }
            ]
        },
        {
            id: 'pda-1',
            title: 'Formal Definition and Stack Operations',
            description: 'Rigorous treatment of PDAs including formal definitions and stack semantics',
            steps: [
                {
                    title: 'Formal Definition of a PDA',
                    content: `A Pushdown Automaton is a 7-tuple P = (Q, Σ, Γ, δ, q₀, Z₀, F) where:

• Q is finite set of states
• Σ is input alphabet
• Γ is stack alphabet
• δ: Q × Σ_ε × Γ_ε → P(Q × Γ*) is transition function
• q₀ ∈ Q is start state
• Z₀ ∈ Γ is initial stack symbol
• F ⊆ Q is set of accept states

Key: δ(q, a, X) returns set of pairs (p, γ) where p is next state and γ is string to push onto stack (top symbol X is replaced by γ).

Acceptance modes:
1. Accept by final state: δ*(q₀, w, Z₀) ⊢* (f, ε, α) for some f ∈ F, α ∈ Γ*
2. Accept by empty stack: δ*(q₀, w, Z₀) ⊢* (q, ε, ε) for any q ∈ Q`,
                    example: {
                        description: 'PDA accepting {0ⁿ1ⁿ | n ≥ 0}',
                        code: `P = (Q, Σ, Γ, δ, q₀, Z₀, F):

Q = {q₀, q₁, q₂}
Σ = {0, 1}
Γ = {Z₀, X}
F = {q₂}

δ(q₀, 0, Z₀) = {(q₀, XZ₀)}  // Push X
δ(q₀, 0, X) = {(q₀, XX)}    // Push X
δ(q₀, ε, Z₀) = {(q₁, Z₀)}  // Switch to popping
δ(q₀, ε, X) = {(q₁, X)}    
δ(q₁, 1, X) = {(q₁, ε)}    // Pop X
δ(q₁, ε, Z₀) = {(q₂, Z₀)}  // Accept`
                    },
                    keyPoints: [
                        'Stack provides unlimited memory (but only top accessible)',
                        'δ can push/pop/replace multiple symbols atomically',
                        'ε-transitions allow state changes without reading input',
                        'Two acceptance modes are equivalent in power'
                    ]
                },
                {
                    title: 'Instantaneous Descriptions and Computations',
                    content: `An Instantaneous Description (ID) is a triple (q, w, γ) where:
• q ∈ Q is current state
• w ∈ Σ* is remaining input
• γ ∈ Γ* is stack contents (top at left)

Transition relation ⊢:
(q, aw, Xβ) ⊢ (p, w, αβ) if (p, α) ∈ δ(q, a, X)

Reflexive transitive closure ⊢* represents computation.

Acceptance (final state):
w ∈ L(P) ⟺ ∃f ∈ F, γ ∈ Γ*: (q₀, w, Z₀) ⊢* (f, ε, γ)

Acceptance (empty stack):
w ∈ N(P) ⟺ ∃q ∈ Q: (q₀, w, Z₀) ⊢* (q, ε, ε)`,
                    keyPoints: [
                        'IDs formalize PDA configurations',
                        '⊢ is single-step transition relation',
                        '⊢* is multi-step computation',
                        'This notation is standard in formal language theory'
                    ]
                },
                {
                    title: 'Equivalence of Acceptance Modes',
                    content: `Theorem: For any PDA P accepting by final state, there exists PDA P' accepting by empty stack with L(P) = N(P'), and vice versa.

Proof sketch (final → empty):
1. Add new start state q₀' with ε-transition pushing special bottom marker
2. From any final state, add ε-transitions to new state that pops everything

Proof sketch (empty → final):
1. Add new bottom marker X₀
2. Add new final state qf
3. When X₀ is exposed (stack would be empty), go to qf

Conclusion: Both models are equivalent, so we can use whichever is more convenient.`,
                    keyPoints: [
                        'Acceptance modes are equivalent in computational power',
                        'Conversion is constructive (algorithmic)',
                        'Choice of mode is matter of convenience',
                        'Most theory uses final state acceptance'
                    ]
                }
            ]
        },
        {
            id: 'pda-2',
            title: 'Context-Free Languages and PDAs',
            description: 'The fundamental connection between PDAs and context-free grammars',
            steps: [
                {
                    title: 'PDA ↔ CFG Equivalence Theorem',
                    content: `Fundamental Theorem: A language L is accepted by some PDA if and only if L is generated by some context-free grammar.

Formally: L is context-free ⟺ ∃ PDA P with L = L(P)

This establishes PDAs as recognizers for exactly the context-free languages!

Proof has two parts:
1. CFG → PDA: Construct PDA that simulates leftmost derivations
2. PDA → CFG: Construct CFG that generates accepting computations

Both constructions are algorithmic and effective.`,
                    keyPoints: [
                        'PDAs and CFGs characterize the same class of languages',
                        'PDAs are recognizers (bottom-up)',
                        'CFGs are generators (top-down)',
                        'This is analogous to DFA ↔ Regular Expression'
                    ]
                },
                {
                    title: 'CFG to PDA Construction',
                    content: `Given CFG G = (V, T, P, S), construct PDA P:

Idea: Simulate leftmost derivations on the stack.

Construction:
• Single state q
• Stack alphabet Γ = V ∪ T
• For each production A → α: δ(q, ε, A) contains (q, α)
• For each terminal a: δ(q, a, a) = {(q, ε)}
• Start with S on stack

Operation:
1. Nondeterministically apply productions (expand variables)
2. Match terminals with input
3. Accept by empty stack

Correctness: S ⇒* w in G ⟺ (q, w, S) ⊢* (q, ε, ε) in P`,
                    example: {
                        description: 'CFG to PDA for balanced parentheses',
                        code: `Grammar:
S → (S) | SS | ε

PDA transitions:
δ(q, ε, S) = {(q, (S)), (q, SS), (q, ε)}
δ(q, (, () = {(q, ε)}  // Match (
δ(q, ), )) = {(q, ε)}  // Match )

Accepts: (), (()), (())(), etc.`
                    },
                    keyPoints: [
                        'Construction is simple and direct',
                        'Single state suffices',
                        'Nondeterminism chooses which production to apply',
                        'Stack holds sentential form of derivation'
                    ]
                }
            ]
        }
    ],
    exercises: [
        {
            id: 'pda-ex-1',
            title: 'PDA Formal Definitions',
            description: 'Test understanding of PDA formalism',
            questions: [
                {
                    type: 'multiple-choice',
                    question: 'What is the type signature of the PDA transition function δ?',
                    options: [
                        'δ: Q × Σ × Γ → Q × Γ*',
                        'δ: Q × Σ_ε × Γ_ε → P(Q × Γ*)',
                        'δ: Q × Σ* × Γ* → Q',
                        'δ: Q × Γ → Q × Σ'
                    ],
                    correctAnswer: 'δ: Q × Σ_ε × Γ_ε → P(Q × Γ*)',
                    explanation: 'The PDA transition function takes (state, input symbol or ε, stack top or ε) and returns a set of (new state, string to push) pairs.',
                    hint: 'Remember PDAs are nondeterministic and can have ε-transitions.'
                },
                {
                    type: 'true-false',
                    question: 'Acceptance by final state and acceptance by empty stack are equivalent in power.',
                    options: ['True', 'False'],
                    correctAnswer: 'True',
                    explanation: 'True! Any PDA accepting by one mode can be converted to accept by the other mode while recognizing the same language.',
                    hint: 'Think about the conversion constructions.'
                },
                {
                    type: 'multiple-choice',
                    question: 'Which language CANNOT be recognized by any PDA?',
                    options: [
                        '{0ⁿ1ⁿ | n ≥ 0}',
                        '{0ⁿ1ⁿ2ⁿ | n ≥ 0}',
                        '{wwᴿ | w ∈ {0,1}*}',
                        'Balanced parentheses'
                    ],
                    correctAnswer: '{0ⁿ1ⁿ2ⁿ | n ≥ 0}',
                    explanation: 'This language requires counting three separate groups, which needs two counters. A PDA has only one stack (one counter).',
                    hint: 'How many independent counts does each language require?'
                },
                {
                    type: 'multiple-choice',
                    question: 'In an instantaneous description (q, w, γ), what does γ represent?',
                    options: [
                        'The input string',
                        'The set of final states',
                        'The stack contents with top at left',
                        'The transition function'
                    ],
                    correctAnswer: 'The stack contents with top at left',
                    explanation: 'In ID notation (q, w, γ), γ ∈ Γ* represents the stack contents with the leftmost symbol being the top.',
                    hint: 'An ID captures the complete configuration of the PDA.'
                }
            ]
        },
        {
            id: 'pda-ex-2',
            title: 'Hands-On: Build Your First PDA',
            description: 'Build PDAs to recognize context-free languages',
            questions: [
                {
                    type: 'hands-on',
                    automatonType: 'PDA',
                    challenge: 'Build a PDA that accepts the language {0ⁿ1ⁿ | n ≥ 0} - equal numbers of 0s followed by 1s.',
                    testCases: [
                        { input: '', expected: true, description: 'Empty string (n=0)' },
                        { input: '01', expected: true, description: 'n=1' },
                        { input: '0011', expected: true, description: 'n=2' },
                        { input: '000111', expected: true, description: 'n=3' },
                        { input: '00001111', expected: true, description: 'n=4' },
                        { input: '0', expected: false, description: 'More 0s than 1s' },
                        { input: '1', expected: false, description: 'More 1s than 0s' },
                        { input: '001', expected: false, description: 'Unequal counts' },
                        { input: '011', expected: false, description: 'Unequal counts' },
                        { input: '0110', expected: false, description: 'Wrong order' }
                    ],
                    hints: [
                        'Use the stack to count 0s',
                        'Push a symbol (like X) for each 0 you read',
                        'Pop a symbol for each 1 you read',
                        'Accept if the stack returns to just the start symbol Z when input ends',
                        'You\'ll need three states: start (q0), counting (q1), and accept (q2)'
                    ],
                    solution: {
                        states: ['q0', 'q1', 'q2'],
                        alphabet: ['0', '1'],
                        stackAlphabet: ['Z', 'X'],
                        startState: 'q0',
                        startStackSymbol: 'Z',
                        acceptStates: ['q2'],
                        transitions: [
                            { from: 'q0', input: 'ε', pop: 'Z', to: 'q2', push: 'Z' },
                            { from: 'q0', input: '0', pop: 'Z', to: 'q1', push: 'XZ' },
                            { from: 'q1', input: '0', pop: 'X', to: 'q1', push: 'XX' },
                            { from: 'q1', input: '1', pop: 'X', to: 'q1', push: 'ε' },
                            { from: 'q1', input: 'ε', pop: 'Z', to: 'q2', push: 'Z' }
                        ]
                    }
                }
            ]
        }
    ]
};


