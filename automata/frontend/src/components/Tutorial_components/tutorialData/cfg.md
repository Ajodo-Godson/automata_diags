Module 3: Context-Free Grammars (CFG)

1. Beyond Regular Languages

We've seen that DFAs/NFAs are limited. They cannot recognize languages that require "counting" or "matching pairs," like:

$L_1 = \{0^n 1^n \mid n \ge 0\}$ (equal numbers of 0s and 1s)

$L_2 = \{w \mid w \text{ is a balanced set of parentheses}\}$ (e.g., "(())", "()()")

These languages are not regular. They belong to a larger class called the Context-Free Languages. To describe these, we move from "recognizers" (automata) to "generators" (grammars).

2. What is a Grammar?

A grammar is a set of rules for generating strings in a language. Think of it like a set of substitution rules.

A Context-Free Grammar (CFG) is a grammar where the substitution rules (called "productions") can be applied regardless of the context.

A rule like $A \to 0A1$ means "The variable $A$ can be replaced by the string '0A1'".

The "context-free" part means $A$ can always be replaced by '0A1', no matter what symbols are to its left or right.

3. Formal Definition (The 4-Tuple)

A CFG is defined as a 4-tuple: $G = (V, T, P, S)$

$V$: A finite set of variables (or "non-terminals"). These are like placeholders.

Convention: Uppercase letters (e.g., $A, B, S$).

$T$: A finite set of terminals (this is the alphabet of the language). These are the actual symbols that appear in the final strings.

Convention: Lowercase letters, numbers, symbols (e.g., $a, b, 0, 1, (, )$).

$V$ and $T$ must be disjoint (a symbol can't be both).

$P$: A finite set of production rules.

Format: $V \to (V \cup T)$*

This means a single variable (left side) is replaced by any string of variables and terminals (right side).

Example: $S \to aSb$, $A \to \epsilon$

$S$: The start variable. This is the variable you begin with. ($S \in V$).

4. How to Use a Grammar: Derivations

You generate a string by starting with the start variable ($S$) and repeatedly applying production rules until no variables are left.

Example 1: Grammar for $L_1 = \{0^n 1^n \mid n \ge 0\}$

$V = \{S\}$

$T = \{0, 1\}$

$S$: Start variable

$P$:

$S \to 0S1$  (This rule adds one '0' and one '1', keeping them balanced)

$S \to \epsilon$   (This rule stops the recursion and allows for $n=0$)

Let's derive the string "0011":

$S$                    (Start with $S$)

$\Rightarrow 0S1$              (Apply rule $S \to 0S1$)

$\Rightarrow 0(0S1)1$            (Apply rule $S \to 0S1$ again)

$\Rightarrow 00\epsilon11$          (Apply rule $S \to \epsilon$)

$\Rightarrow 0011$             (The $\epsilon$ disappears)

Since we derived "0011" from $S$, this string is in the language generated by the grammar.

Example 2: Grammar for balanced parentheses $L_2$

$V = \{S\}$

$T = \{(, )\}$

$S$: Start variable

$P$:

$S \to (S)$   (Rule for nesting: ( ... ))

$S \to SS$    (Rule for sequence: ... ...)

$S \to \epsilon$   (Rule for the empty string, the base case)

Let's derive "()(())":

$S$

$\Rightarrow SS$             (Apply $S \to SS$)

$\Rightarrow (S)S$            (Apply $S \to (S)$ to the first $S$)

$\Rightarrow ()S$            (Apply $S \to \epsilon$ to the $S$ inside parentheses)

$\Rightarrow ()(S)$           (Apply $S \to (S)$ to the second $S$)

$\Rightarrow ()( (S) )$         (Apply $S \to (S)$ again)

$\Rightarrow ()( () )$         (Apply $S \to \epsilon$)

$\Rightarrow ()(())$

5. Parse Trees

A derivation can also be represented visually as a parse tree. This tree shows how the string was generated and is crucial for compilers (which check if your code syntax is valid).

Parse Tree for "0011" (from Example 1):

      S
     /|\
    0 S 1
     /|\
    0 S 1
      |
      Îµ


The root is the start variable $S$.

Internal nodes are variables ($V$).

Leaves are terminals ($T$) or $\epsilon$.

Reading the leaves from left to right gives the generated string: "0 0 $\epsilon$ 1 1" = "0011".

A grammar is ambiguous if there is at least one string that has two or more different parse trees. This is often undesirable in programming languages, as it means a line of code could be interpreted in multiple ways.

Example of Ambiguity (Simple arithmetic):

$E \to E + E$

$E \to E * E$

$E \to \text{id}$  (where 'id' stands for a number/identifier)

The string "id + id * id" can be parsed in two ways:

(id + id) * id

id + (id * id)
This grammar is ambiguous because it doesn't define operator precedence (that * comes before +).

6. CFGs and Regular Languages

Every Regular Language is also a Context-Free Language. This means we can write a CFG for any language that a DFA can recognize. The hierarchy of languages looks like this:

Regular Languages $\subset$ Context-Free Languages $\subset$ ... (more complex classes)

CFGs are the theoretical basis for most modern programming language parsers.