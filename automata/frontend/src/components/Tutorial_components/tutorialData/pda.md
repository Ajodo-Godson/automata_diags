Module 4: Pushdown Automata (PDA)

1. The Machine for CFGs

We saw that:

Regular Languages are recognized by Finite Automata (DFAs/NFAs).

Context-Free Languages are generated by Context-Free Grammars (CFGs).

What is the automaton (recognizer) for a Context-Free Language?
The answer is the Pushdown Automaton (PDA).

2. Why Finite Automata Fail

Why can't a DFA recognize $L = \{0^n 1^n \mid n \ge 0\}$?
A DFA has only a finite number of states. It has no "memory" to count how many 0s it has seen, in order to check if it matches the number of 1s.

3. The Power of a Stack

A Pushdown Automaton is essentially a Nondeterministic Finite Automaton (NFA) with one extra component: a stack.

A stack is a "Last-In, First-Out" (LIFO) data structure.

PUSH: Add an item to the top of the stack.

POP: Remove the top item from the stack.

This stack gives the automaton a simple, but infinite, memory. It can use the stack to "count."

How a PDA recognizes $L = \{0^n 1^n\}$:

While reading '0's, PUSH a '0' (or some marker, say '$') onto the stack for each '0' read.

When you start reading '1's, POP one '0' from the stack for each '1' read.

If the stack becomes empty at the exact same time you finish reading the string, you have a match.

Accept the string.

If you run out of input '1's but the stack still has '0's on it (e.g., "00011"), Reject.

If you still have '1's to read but the stack is empty (e.g., "00111"), Reject.

If you see a '0' after a '1' (e.g., "0101"), Reject (this is handled by the state logic).

4. How a PDA Works

A PDA's transition depends on three things:

The current state.

The current input symbol (or $\epsilon$).

The symbol at the top of the stack.

Based on these three things, the PDA does two things:

Transitions to a new state.

Modifies the stack (it can PUSH, POP, or do nothing).

Note: PDAs are almost always nondeterministic. A 'Deterministic PDA' (DPDA) is a much weaker model and cannot recognize all CFLs. The nondeterminism is crucial for "guessing" (e.g., "is this the middle of the string?").

5. Formal Definition (The 7-Tuple)

This is the most complex definition yet: $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$

$Q$: Finite set of states.

$\Sigma$: Finite input alphabet.

$\Gamma$ (Gamma): Finite stack alphabet. (The symbols you're allowed to put on the stack).

$\delta$: The transition function. This is the complex part.

Format: $\delta: Q \times (\Sigma \cup \{\epsilon\}) \times (\Gamma \cup \{\epsilon\}) \to P(Q \times (\Gamma \cup \{\epsilon\}))$

Input: (current state, input symbol, stack top)

Output: A set of (new state, new stack top)

Example: $\delta(q_0, 0, \epsilon) = \{(q_0, \$)\}$

"If in state $q_0$, and you read input '0', and the stack top is $\epsilon$ (empty),

...then go to state $q_0$ and PUSH '$' onto the stack."

(Note: PUSH is represented by (new_state, symbol_to_push). POP is (new_state, $\epsilon$))

$q_0$: The start state.

$Z_0$: The initial stack symbol. A special symbol on the stack bottom.

$F$: The set of accept states.

Two Types of Acceptance

A PDA can accept a string in two different (but equivalent) ways:

Acceptance by Final State (what we've described): The machine finishes reading the input and is in an accept state (just like an NFA).

Acceptance by Empty Stack: The machine finishes reading the input, and the stack is empty (regardless of what state it's in).

These two models of acceptance are equivalent in power (you can convert one to the other).

6. Example: PDA for $L = \{0^n 1^n \mid n \ge 0\}$

Let's design a PDA that accepts by empty stack.

$Q = \{q_0, q_1\}$

$\Sigma = \{0, 1\}$

$\Gamma = \{0, \$\}$  (We'll push '0's and a bottom-marker '$')

$q_0$: Start state

$Z_0 = \$$

$F = \{\}$ (We don't need final states if we accept by empty stack)

Transitions ($\delta$):

Start: $\delta(q_0, \epsilon, \epsilon) = \{(q_0, \$)\}$

Self-correction: A better start rule puts the marker on.

Let's assume the machine starts with $Z_0 = \$$ on the stack.

$q_0$ = "pushing 0s" state

$q_1$ = "popping 0s" state

Rule 1 (Push 0s): $\delta(q_0, 0, \epsilon) = \{(q_0, 0)\}$

This is slightly simplified. Let's be more precise.

$\delta(q_0, 0, \$) = \{(q_0, 0\$)\}$  (Push '0' onto the '$')

$\delta(q_0, 0, 0) = \{(q_0, 00)\}$  (Push '0' onto another '0')

In English: If in state $q_0$ and we read a '0', PUSH a '0' onto the stack.

Rule 2 (Switch to 1s): $\delta(q_0, 1, 0) = \{(q_1, \epsilon)\}$

In English: If in state $q_0$ (pushing 0s) and we read a '1', and the stack top is '0',

...then transition to state $q_1$ (popping 1s) and POP the '0' (replace '0' with $\epsilon$).

This is the first '1' we see. This is a nondeterministic choice point.

Rule 3 (Pop 0s): $\delta(q_1, 1, 0) = \{(q_1, \epsilon)\}$

In English: If we are in state $q_1$ (popping 1s) and we read a '1', and the stack top is '0',

...then stay in state $q_1$ and POP the '0'.

Rule 4 (Finish): $\delta(q_1, \epsilon, \$) = \{(q_1, \epsilon)\}$

In English: If we are in state $q_1$, we are out of input, and the only thing on the stack is the bottom marker '$',

...then POP the '$'. The stack is now empty. ACCEPT.

7. The Big Picture

PDAs are more powerful than NFAs/DFAs, but they are not all-powerful.
For example, a PDA cannot recognize the language $L = \{a^n b^n c^n \mid n \ge 0\}$.
Why? It can use its stack to match the $a$'s and $b$'s. But by the time it gets to the $c$'s, the stack is empty, and it has no memory of how many $a$'s and $b$'s it saw. It can't match all three.

The Chomsky Hierarchy (so far):
| Language Class | Generator | Recognizer |
| :--- | :--- | :--- |
| Regular | Regular Grammar | DFA / NFA |
| Context-Free | CFG | PDA |