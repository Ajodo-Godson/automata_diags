// CFG Tutorial Content - Rigorous Treatment

export const cfgTutorial = {
    description: "Master Context-Free Grammars through formal definitions, derivations, parse trees, and normal forms including Chomsky Normal Form.",
    lessons: [
        {
            id: 'cfg-0',
            title: 'Introduction: Beyond Regular Languages',
            description: 'An intuitive introduction to Context-Free Grammars and why we need them',
            steps: [
                {
                    title: 'Beyond Regular Languages',
                    content: `We've seen that DFAs/NFAs are limited. They cannot recognize languages that require "counting" or "matching pairs," like:

• L₁ = {0ⁿ1ⁿ | n ≥ 0} (equal numbers of 0s and 1s)
• L₂ = {w | w is a balanced set of parentheses} (e.g., "(())", "()()")

These languages are not regular. They belong to a larger class called the Context-Free Languages.

To describe these, we move from "recognizers" (automata) to "generators" (grammars).`,
                    keyPoints: [
                        'Regular languages are limited',
                        'Need more power for nested structures',
                        'Context-free languages are more expressive',
                        'Grammars generate, automata recognize'
                    ]
                },
                {
                    title: 'What is a Grammar?',
                    content: `A grammar is a set of rules for generating strings in a language. Think of it like a set of substitution rules.

A Context-Free Grammar (CFG) is a grammar where the substitution rules (called "productions") can be applied regardless of the context.

A rule like A → 0A1 means "The variable A can be replaced by the string '0A1'."

The "context-free" part means A can always be replaced by '0A1', no matter what symbols are to its left or right.

This is different from context-sensitive grammars, where rules might depend on surrounding symbols.`,
                    keyPoints: [
                        'Grammars generate strings',
                        'Productions are substitution rules',
                        'Context-free = rules don\'t depend on context',
                        'More flexible than regular grammars'
                    ],
                    tips: [
                        'Think of grammar as a "recipe"',
                        'Start with a variable, apply rules',
                        'Keep applying until only terminals remain',
                        'The result is a string in the language'
                    ]
                },
                {
                    title: 'Example: Grammar for 0ⁿ1ⁿ',
                    content: `Let's design a grammar for L₁ = {0ⁿ1ⁿ | n ≥ 0}.

Grammar:
V = {S}
T = {0, 1}
S: Start variable

Productions:
• S → 0S1  (This rule adds one '0' and one '1', keeping them balanced)
• S → ε     (This rule stops the recursion and allows for n=0)

Let's derive the string "0011":

S                    (Start with S)
⇒ 0S1                (Apply rule S → 0S1)
⇒ 0(0S1)1            (Apply rule S → 0S1 again)
⇒ 00ε11              (Apply rule S → ε)
⇒ 0011               (The ε disappears)

Since we derived "0011" from S, this string is in the language generated by the grammar.`,
                    example: {
                        description: 'Step-by-step derivation',
                        code: `Derivation of "0011":

Step 1: S
Step 2: S → 0S1
        Result: 0S1
Step 3: S → 0S1 (on the S in 0S1)
        Result: 00S11
Step 4: S → ε
        Result: 00ε11
Step 5: Remove ε
        Final: 0011 ✓

Derivation of "01":
S → 0S1 → 0ε1 → 01 ✓

Derivation of "" (empty string):
S → ε ✓`
                    },
                    keyPoints: [
                        'Productions build strings recursively',
                        'S → 0S1 keeps 0s and 1s balanced',
                        'S → ε provides the base case',
                        'Derivation shows how string is generated'
                    ]
                },
                {
                    title: 'Example: Grammar for Balanced Parentheses',
                    content: `Grammar for L₂ = balanced parentheses:

V = {S}
T = {(, )}
S: Start variable

Productions:
• S → (S)   (Rule for nesting: ( ... ))
• S → SS    (Rule for sequence: ... ...)
• S → ε     (Rule for the empty string, the base case)

Let's derive "()(())":

S
⇒ SS             (Apply S → SS)
⇒ (S)S           (Apply S → (S) to the first S)
⇒ ()S            (Apply S → ε to the S inside parentheses)
⇒ ()(S)          (Apply S → (S) to the second S)
⇒ ()((S))        (Apply S → (S) again)
⇒ ()(())         (Apply S → ε)

This grammar captures the recursive structure of nested parentheses!`,
                    keyPoints: [
                        'S → (S) handles nesting',
                        'S → SS handles concatenation',
                        'S → ε handles base case',
                        'Can generate arbitrarily nested structures'
                    ],
                    tips: [
                        'Think: "balanced" means properly nested',
                        'Each ( must have a matching )',
                        'Can nest arbitrarily deep',
                        'This is why CFGs are powerful'
                    ]
                },
                {
                    title: 'Parse Trees',
                    content: `A derivation can also be represented visually as a parse tree. This tree shows how the string was generated and is crucial for compilers (which check if your code syntax is valid).

Parse Tree for "0011" (from Example 1):

      S
     /|\\
    0 S 1
     /|\\
    0 S 1
      |
      ε

The root is the start variable S.

Internal nodes are variables (V).

Leaves are terminals (T) or ε.

Reading the leaves from left to right gives the generated string: "0 0 ε 1 1" = "0011".

A grammar is ambiguous if there is at least one string that has two or more different parse trees. This is often undesirable in programming languages, as it means a line of code could be interpreted in multiple ways.`,
                    example: {
                        description: 'Ambiguous grammar example',
                        code: `Grammar for simple arithmetic:
E → E + E
E → E * E
E → id  (where 'id' stands for a number/identifier)

The string "id + id * id" can be parsed in two ways:

Parse Tree 1:          Parse Tree 2:
      E                     E
     /|\\                   /|\\
    E + E                 E * E
    |   /|\\              /|\\  |
   id  E * E            E + E id
       |   |            |   |
      id  id           id  id

Tree 1: (id + id) * id  (wrong precedence!)
Tree 2: id + (id * id)  (correct precedence)

This grammar is ambiguous because it doesn't define operator precedence.`
                    },
                    keyPoints: [
                        'Parse trees show structure',
                        'Ambiguity = multiple trees',
                        'Problematic for programming languages',
                        'Need unambiguous grammars'
                    ]
                },
                {
                    title: 'CFGs and Regular Languages',
                    content: `Every Regular Language is also a Context-Free Language. This means we can write a CFG for any language that a DFA can recognize.

The hierarchy of languages looks like this:

Regular Languages ⊂ Context-Free Languages ⊂ ... (more complex classes)

CFGs are the theoretical basis for most modern programming language parsers.

Key insight: CFGs can describe nested, recursive structures that regular languages cannot.`,
                    keyPoints: [
                        'Regular ⊂ Context-Free',
                        'CFGs are more powerful',
                        'Foundation of parser design',
                        'Used in compilers and interpreters'
                    ],
                    tips: [
                        'Every regular language has a CFG',
                        'But not every CFG language is regular',
                        'CFGs add recursion and nesting',
                        'This is why they\'re so useful'
                    ]
                }
            ]
        },
        {
            id: 'cfg-1',
            title: 'Formal Definitions and Derivations',
            description: 'Rigorous treatment of CFGs, derivations, and parse trees',
            steps: [
                {
                    title: 'Formal Definition of a CFG',
                    content: `A Context-Free Grammar is a 4-tuple G = (V, T, P, S) where:

• V is finite set of variables (non-terminals)
• T is finite set of terminals (disjoint from V)
• P ⊆ V × (V ∪ T)* is finite set of production rules
• S ∈ V is the start variable

Production notation: A → α where A ∈ V and α ∈ (V ∪ T)*

Derivation relation ⇒:
αAβ ⇒ αγβ if A → γ ∈ P

Language generated:
L(G) = {w ∈ T* | S ⇒* w}`,
                    example: {
                        description: 'Grammar for balanced parentheses',
                        code: `G = (V, T, P, S):

V = {S}
T = {(, )}
S is start variable

P: S → (S) | SS | ε

Derivation of "(())":
S ⇒ (S) ⇒ ((S)) ⇒ (())


L(G) = {ε, (), (()), ()(), (())(), ...}`
                    },
                    keyPoints: [
                        'Variables can be replaced by any production right-hand side',
                        'Only variables can be replaced (context-free property)',
                        'Language is all terminal strings derivable from S',
                        'Empty productions (A → ε) are allowed'
                    ]
                },
                {
                    title: 'Leftmost and Rightmost Derivations',
                    content: `Leftmost derivation: Always replace leftmost variable
Rightmost derivation: Always replace rightmost variable

Notation:
• ⇒_lm for leftmost derivation step
• ⇒_rm for rightmost derivation step

Theorem: For any derivation S ⇒* w, there exist unique leftmost and rightmost derivations.

Importance:
• Leftmost: Top-down parsing (LL parsers)
• Rightmost: Bottom-up parsing (LR parsers)
• Both generate same parse tree

Ambiguity: Grammar is ambiguous if some string has multiple parse trees (equivalently, multiple leftmost derivations).`,
                    example: {
                        description: 'Ambiguous arithmetic grammar',
                        code: `Grammar:
E → E + E | E * E | (E) | id

String: id + id * id

Derivation 1:
E ⇒ E + E ⇒ id + E ⇒ id + E * E ⇒ id + id * id
(Gives (id + id) * id parsing)

Derivation 2:
E ⇒ E * E ⇒ E + E * E ⇒ id + E * E ⇒ id + id * id
(Gives id + (id * id) parsing)

Ambiguous!`
                    },
                    keyPoints: [
                        'Leftmost/rightmost derivations unique for given parse tree',
                        'Different parse trees mean ambiguity',
                        'Ambiguity is undecidable in general',
                        'Many CFLs have unambiguous grammars'
                    ]
                },
                {
                    title: 'Parse Trees and Yield',
                    content: `A parse tree for derivation S ⇒* w has:
• Root labeled S
• Interior nodes labeled with variables
• Leaves labeled with terminals or ε
• If node A has children X₁...Xₖ, then A → X₁...Xₖ ∈ P

Yield of tree: concatenation of leaf labels (left to right)

Theorem: w ∈ L(G) ⟺ ∃ parse tree with yield w

Parse tree represents syntactic structure independently of derivation order.

Height of parse tree = length of longest path from root to leaf.

Pumping Lemma (for CFLs): Uses parse tree height to prove non-context-freeness.`,
                    keyPoints: [
                        'Parse trees show hierarchical structure',
                        'Same tree can correspond to different derivations',
                        'Yield connects trees to strings',
                        'Tree height important for pumping lemma'
                    ]
                }
            ]
        },
        {
            id: 'cfg-2',
            title: 'Chomsky Normal Form and Parsing',
            description: 'Normal forms for CFGs and their applications',
            steps: [
                {
                    title: 'Chomsky Normal Form (CNF)',
                    content: `A CFG is in Chomsky Normal Form if every production has one of these forms:
1. A → BC (two variables)
2. A → a (single terminal)
3. S → ε (only if ε ∈ L(G))

Theorem: Every CFG can be converted to CNF.

Conversion algorithm:
1. Add new start variable S'
2. Eliminate ε-productions (A → ε)
3. Eliminate unit productions (A → B)
4. Convert long productions: A → X₁X₂...Xₖ (k ≥ 3)
5. Isolate terminals in long productions

Result: Grammar in CNF generating same language (minus possibly ε).`,
                    example: {
                        description: 'Converting to CNF',
                        code: `Original:
S → ASB | ε
A → aA | ε
B → b

After eliminating ε:
S → ASB | AB | AS | SB | S | ε
A → aA | a
B → b

After eliminating unit:
S → ASB | AB | AS | SB | aA | a | ε
A → aA | a
B → b

CNF:
S₀ → S | ε
S → AT₁ | AB | AS | SB | CA | a
T₁ → SB
A → CA | a
B → b
C → a`
                    },
                    keyPoints: [
                        'CNF has only binary and unary productions',
                        'Conversion doesn\'t change language',
                        'CNF useful for parsing algorithms',
                        'All parse trees have balanced shape'
                    ]
                },
                {
                    title: 'CYK Parsing Algorithm',
                    content: `The Cocke-Younger-Kasami algorithm parses strings using CNF grammars.

Time complexity: O(n³|G|) where n = |w|, |G| = grammar size
Idea: Dynamic programming
• Build table T[i,j,A]: true iff A ⇒* w[i...j]
• Base case: T[i,i,A] = true if A → w[i]
• Recursive: T[i,j,A] = true if ∃ k, B, C:
  A → BC ∈ P and T[i,k,B] and T[k+1,j,C]
Result: w ∈ L(G) ⟺ T[1,n,S] = true




This is optimal for worst-case general CFG parsing.`,
                    keyPoints: [
                        'CYK requires grammar in CNF',
                        'O(n³) time complexity',
                        'Bottom-up dynamic programming',
                        'Can be extended to find all parse trees'
                    ]
                },
                {
                    title: 'Recursive Top-Down Parsing',
                    content: `When verifying that a string belongs to a context-free language, we can use recursion.

If a grammar is in **Chomsky Normal Form (CNF)**, we can use a very structured recursive approach to check if a string $w$ is in the language:

1. **Base Case (Length ≤ 1)**:
   • If $w = ε$, check if there is a rule $S → ε$.
   • If $w = a$ (a single terminal), check if there is a rule $S → a$.
2. **Recursive Step (Length > 1)**:
   • For every rule $A → BC$, try splitting the string $w$ into two parts $w_1$ and $w_2$ in all possible ways ($w = w_1w_2$).
   • Recursively check if $B \\Rightarrow^* w_1$ AND $C \\Rightarrow^* w_2$.

This structured decomposition is only possible because CNF rules are restricted to exactly two variables on the right-hand side.`,
                    keyPoints: [
                        'CNF allows for a clean, recursive split-and-conquer parsing strategy',
                        'For a string of length $n$, a CNF derivation always takes exactly $2n-1$ steps',
                        'This predictability is why CNF is so important for computer parsers'
                    ],
                    tips: [
                        'Think of it as trying every possible way to cut the string in half',
                        'If any cut works, the whole string is valid',
                        'This is the intuitive version of what the CYK algorithm does more efficiently'
                    ]
                }
            ]
        }
    ],
    exercises: [
        {
            id: 'cfg-ex-basics',
            title: 'Basics: Parsing and Normal Forms',
            description: 'Test your understanding of grammar structure and predictability',
            questions: [
                {
                    type: 'multiple-choice',
                    question: 'If a context-free grammar is in Chomsky Normal Form, how many steps are in the derivation of a string of length n > 0?',
                    options: [
                        'n steps',
                        '2n steps',
                        '2n - 1 steps',
                        'n² steps'
                    ],
                    correctAnswer: '2n - 1 steps',
                    explanation: 'As noted in the instructor guide, if G is a CFG in CNF, exactly 2n-1 steps are required for any derivation of a string of length n ≥ 1. This includes n-1 applications of A → BC and n applications of A → a.',
                    hint: 'Count the number of variable expansions vs terminal productions.'
                },
                {
                    type: 'multiple-choice',
                    question: 'In the recursive top-down parsing strategy, what do you do for a rule A → BC?',
                    options: [
                        'Replace A with B and ignore C',
                        'Try all possible ways to split the string into two parts and check them against B and C',
                        'Wait for more input',
                        'Only check if the first character matches B'
                    ],
                    correctAnswer: 'Try all possible ways to split the string into two parts and check them against B and C',
                    explanation: 'The strategy involves splitting the string w into w₁ and w₂ and recursively checking if B generates w₁ and C generates w₂.',
                    hint: 'Think about how you would verify a binary tree structure.'
                },
                {
                    type: 'true-false',
                    question: 'If n ≤ 1, you can determine if a string is in L(G) by checking only one production rule if G is in CNF.',
                    options: ['True', 'False'],
                    correctAnswer: 'True',
                    explanation: 'True. If n=0 (empty string), you just check S → ε. If n=1 (single terminal), you just check S → a.',
                    hint: 'How many steps would a derivation of length 1 take in CNF?'
                }
            ]
        },
        {
            id: 'cfg-ex-1',
            title: 'CFG Fundamentals',
            description: 'Test understanding of CFG definitions and derivations',
            questions: [
                {
                    type: 'multiple-choice',
                    question: 'In a CFG production A → α, what can A be?',
                    options: [
                        'Any symbol from V ∪ T',
                        'Only a variable from V',
                        'Only a terminal from T',
                        'A string from (V ∪ T)*'
                    ],
                    correctAnswer: 'Only a variable from V',
                    explanation: 'In context-free grammars, the left-hand side of a production must be a single variable. This is what makes them "context-free".',
                    hint: 'What makes a grammar "context-free"?'
                },
                {
                    type: 'true-false',
                    question: 'Every string in L(G) has a unique leftmost derivation.',
                    options: ['True', 'False'],
                    correctAnswer: 'False',
                    explanation: 'False for ambiguous grammars. A string may have multiple parse trees, each corresponding to a distinct leftmost derivation.',
                    hint: 'Think about ambiguous grammars.'
                },
                {
                    type: 'multiple-choice',
                    question: 'What does it mean for a grammar to be ambiguous?',
                    options: [
                        'Some production is undefined',
                        'Some string has multiple parse trees',
                        'The language is not context-free',
                        'No derivation exists for some strings'
                    ],
                    correctAnswer: 'Some string has multiple parse trees',
                    explanation: 'A grammar is ambiguous if at least one string in its language has two or more distinct parse trees (or equivalently, multiple leftmost derivations).',
                    hint: 'Ambiguity relates to structure, not membership.'
                },
                {
                    type: 'multiple-choice',
                    question: 'In Chomsky Normal Form, what forms can productions take?',
                    options: [
                        'A → a only',
                        'A → BC or A → a (and S → ε)',
                        'A → α for any α',
                        'A → ε or A → a'
                    ],
                    correctAnswer: 'A → BC or A → a (and S → ε)',
                    explanation: 'CNF allows A → BC (two variables), A → a (one terminal), and S → ε only if ε is in the language.',
                    hint: 'CNF restricts right-hand sides to length 1 or 2.'
                }
            ]
        },
        {
            id: 'cfg-ex-2',
            title: 'Hands-On: Build Context-Free Grammars',
            description: 'Practice designing grammars that generate complex languages',
            questions: [
                {
                    type: 'hands-on',
                    question: 'Build a CFG that generates the language {0ⁿ1ⁿ | n ≥ 1}',
                    simulatorType: 'CFG',
                    challenge: {
                        terminals: ['0', '1'],
                        variables: ['S'],
                        description: 'Create a Context-Free Grammar that generates equal numbers of 0s followed by 1s (at least one of each). Your grammar should generate strings like "01", "0011", "000111", but NOT "", "0", "1", "001", or "0110".',
                        testCases: [
                            { input: '01', expected: true, description: 'n=1' },
                            { input: '0011', expected: true, description: 'n=2' },
                            { input: '000111', expected: true, description: 'n=3' },
                            { input: '00001111', expected: true, description: 'n=4' },
                            { input: '', expected: false, description: 'Empty string (n=0)' },
                            { input: '0', expected: false, description: 'Only 0s' },
                            { input: '1', expected: false, description: 'Only 1s' },
                            { input: '001', expected: false, description: 'Unequal counts' },
                            { input: '011', expected: false, description: 'Unequal counts' },
                            { input: '0110', expected: false, description: 'Wrong order' }
                        ],
                        hints: [
                            'Start with a single variable S.',
                            'Think recursively: wrap each pair in more 0s and 1s.',
                            'Base case: S → 01',
                            'Recursive case: S → 0S1',
                            'The complete grammar has just two productions: S → 01 | 0S1'
                        ]
                    },
                    explanation: 'The rule S → 0S1 recursively adds a 0 on the left and a 1 on the right, maintaining perfect balance.'
                },
                {
                    type: 'hands-on',
                    question: 'Build a CFG for Balanced Parentheses over {(, )}',
                    simulatorType: 'CFG',
                    challenge: {
                        terminals: ['(', ')'],
                        variables: ['S'],
                        description: 'Design a grammar that generates correctly balanced parentheses. Examples: "()", "(())", "()()", "((()))". Reject: "(", ")", "()(", "())".',
                        testCases: [
                            { input: '', expected: true, description: 'Empty string' },
                            { input: '()', expected: true, description: 'Simple' },
                            { input: '(())', expected: true, description: 'Nested' },
                            { input: '()()', expected: true, description: 'Sequence' },
                            { input: '((()))', expected: true, description: 'Deep nesting' },
                            { input: '(()())', expected: true, description: 'Complex' },
                            { input: '(', expected: false, description: 'Unclosed' },
                            { input: ')', expected: false, description: 'Unopened' },
                            { input: '())', expected: false, description: 'Extra closing' }
                        ],
                        hints: [
                            'There are three main ways to build balanced parentheses: nesting, concatenation, and empty.',
                            'S → (S) handles the nesting (like (()) ).',
                            'S → SS handles the concatenation (like ()() ).',
                            'S → ε handles the empty string.',
                            'Combine these into a single set of rules for S.'
                        ]
                    },
                    explanation: 'This grammar is the classic example of a recursive structure. S → (S) provides depth, while S → SS provides breadth.'
                },
                {
                    type: 'hands-on',
                    question: 'Build a CFG for Palindromes over {a,b}',
                    simulatorType: 'CFG',
                    challenge: {
                        terminals: ['a', 'b'],
                        variables: ['S'],
                        description: 'Design a grammar that generates all palindromes (strings that read the same forwards and backwards) over the alphabet {a,b}. Examples: "a", "b", "aa", "aba", "abba".',
                        testCases: [
                            { input: '', expected: true, description: 'Empty string' },
                            { input: 'a', expected: true, description: 'Single a' },
                            { input: 'b', expected: true, description: 'Single b' },
                            { input: 'aa', expected: true, description: 'Even length a' },
                            { input: 'aba', expected: true, description: 'Odd length' },
                            { input: 'abba', expected: true, description: 'Even length' },
                            { input: 'baab', expected: true, description: 'Even length' },
                            { input: 'ab', expected: false, description: 'Not a palindrome' },
                            { input: 'aab', expected: false, description: 'Not a palindrome' }
                        ],
                        hints: [
                            'A palindrome either starts and ends with the same symbol, or it\'s a very short base case.',
                            'Base cases: S → a, S → b, and S → ε (to handle odd and even lengths).',
                            'Recursive cases: S → aSa and S → bSb.',
                            'Combine all five productions to generate all possible palindromes.'
                        ]
                    },
                    explanation: 'Palindromes are inherently recursive. If you take a palindrome and add the same symbol to both ends, you get a new palindrome.'
                }
            ]
        }
    ]
};


